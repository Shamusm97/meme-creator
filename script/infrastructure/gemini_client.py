from google import genai
from google.genai import types
from typing import List, Optional
from dataclasses import dataclass

from config.domain.models import ScriptConfig, Character
from script.domain.models import LLMClient, ScriptEntry


@dataclass
class GeminiConfig:
    """Configuration for the Gemini LLM client"""

    temperature: float
    max_output_tokens: int
    model: str
    direct_output: bool
    thinking_config: types.ThinkingConfig

    def __post_init__(self):
        if not (0 <= self.temperature <= 2):
            raise ValueError("Temperature must be between 0 and 2")
        if self.max_output_tokens <= 0:
            raise ValueError("max_output_tokens must be a positive integer")


class GeminiLLMClient(LLMClient):
    def __init__(self, gemini_config: GeminiConfig, api_key: Optional[str] = None):
        """
        Initialize the Google LLM client with validated configuration.

        Args:
            gemini_config: Pre-validated Gemini configuration
            api_key: Google API key. If None, will try to get from environment variable.
        """
        if api_key:
            self.client = genai.Client(api_key=api_key)
        else:
            # Will automatically pick up GEMINI_API_KEY or GOOGLE_API_KEY from environment
            self.client = genai.Client()

        # Store validated config
        self.config = gemini_config

    def generate_script(
        self,
        script_config: ScriptConfig,
    ) -> List[ScriptEntry]:
        try:
            print("=== GENERATING SCRIPT ===")
            user_prompt = script_config.user_prompt.strip()

            # Modify prompt to encourage direct output if requested

            # Configure generation parameters using stored config
            genai_config = self._create_genai_config(script_config.system_prompt)

            # Generate response
            response = self.client.models.generate_content(
                model=self.config.model, contents=user_prompt, config=genai_config
            )

            if not response or not response.text:
                raise ValueError("No content generated by the model.")

            print("=== SCRIPT GENERATED ===")

            raw_script_content = response.text.strip()
            parsed_script = self.parse_script_with_characters(characters=script_config.characters, script=raw_script_content)
            print(f"Parsed {len(parsed_script)} entries from generated script.")

            return parsed_script

        except Exception as e:
            raise Exception(f"Error generating content: {str(e)}")

    def _create_genai_config(self, system_prompt: str) -> types.GenerateContentConfig:
        """Convert stored config to Google GenAI config format."""
        return types.GenerateContentConfig(
            system_instruction=system_prompt,
            temperature=self.config.temperature,
            max_output_tokens=self.config.max_output_tokens,
            thinking_config=self.config.thinking_config,
        )

    def validate_script(self, script: str) -> List[str]:
        """Validate script format and return list of error messages"""
        errors = []
        for i, line in enumerate(script.split("\n"), 1):
            if line.strip() and ":" not in line:
                errors.append(f"Line {i}: Missing colon - '{line.strip()}'")
        return errors

    def parse_script_with_characters(self, characters: List[Character], script: str) -> List[ScriptEntry]:
        """Parse script into structured data"""
        # Validate first
        errors = self.validate_script(script)
        if errors:
            raise ValueError(f"Invalid script format: {', '.join(errors)}")

        # Parse valid entries
        script_entries = []
        for line in script.split("\n"):
            if ":" in line:
                character_name, content = line.split(":", 1)
                print(f"Processing character: {character_name.strip()} with content: {content.strip()}")
                for character in characters:
                    if character.name.lower() == character_name.strip().lower():
                        # Match found, create ScriptEntry
                        script_entries.append(
                            ScriptEntry(character=character, content=content.strip())
                        )
                        break
                else:
                    # No match found, create a generic ScriptEntry
                    script_entries.append(
                        ScriptEntry(character=Character(name=character_name.strip()), content=content.strip())
                    )

        if not script_entries:
            raise ValueError("No valid script entries found after parsing.")

        return script_entries


def save_script(content: str, filename: str) -> None:
    """Save script content to file."""
    with open(filename, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"Script saved to: {filename}")


def load_template(template_file: str) -> str:
    """Load system prompt template from file."""
    with open(template_file, "r", encoding="utf-8") as f:
        return f.read()
